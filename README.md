# by sole
class stack of strings
Task2 - cmc - 4 sem

#### how it works: 

    :make pr
    :input | ./pr 

or

    :./pr

to test

    :make test
    :./test

#### commands: (/help) 

        push   - string to stack
        pop    - string from stack
        peek   - string from stack (no del)
        print  - print stack
        length - number of strings in stack
        size   - maxsize of stack
        stack+ - push str to stack
        stack- - pop to str, maxsize = 10
        
#### examples:

      push 1 2 3 4 5 push // now 1-5 in stack
      pop // 1-4 in stack
      peek // 1-4 in stack
      stack- str //now str = 4, 1-3 in stack
      stack+ s //stack: 1 2 3 s
      stack+ str //stack: 1 2 3 s 4
      pop pop pop pop pop 
      stack empty!
      
 -----------
      
## Task2: Stack of strings class

Необходимо на Си++ реализовать и протестировать новый класс, представляющий

абстрактный тип данных, т.е. такой, пользователи которого могут обращаться

только к публичными операциями, предусмотренными создателем класса, и не имеют

информации о внутреннем его устройстве.

Здесь и далее пользователем (клиентом) класса считается не "пользователь программы" или

"компьютерный пользователь" вообще, а программист, использующий Ваш класс

для решения своих задач, пишущий свою программу на его основе.

Иногда также под пользователями класса понимаются другие классы,

фрагменты программ, которые пользуются его услугами.

Ниже перечислены варианты понятий, которые нужно представить новым классом.

Можно определить несколько дополнительных классов, на том же уровне или вложенных,

однако основной проверке подвергается главный класс. В некоторых вариантах

есть подварианты -- одно- или двунаправленный список, чем ограничена длина строки и т.п.,

влияющие на сложность задания. Среди подвариантов нужно сделать свой выбор и отразить его в README.

Чем сложнее вариант/подварианты, тем больше баллов можно получить за выполненное задание.

Первые четыре задания сформулированы подробно, остальные -- более кратко,

для интерпретации по аналогии. Полезные замечания разбросаны по

заданиям, поэтому рекомендуется прочитать их все. :)

Расширение предложенного набора операций, и прочее превышение задания

(при сохранении правильности базовой части) приветствуется и награждается :)

  -----------
 == Требования к любому варианту ==
 
Программа формируется в виде следующего набора файлов (например, для стека строк):

        README
        Makefile
        string_stack.h
        string_stack.cpp
        main.cpp

В файле string_stack.h должно быть объявлено все, что необходимо включить в программу,

использующую класс string_stack, в string_stack.cpp -- описаны реализации нетривиальных методов класса

(если содержат более одного-двух операторов), краткие методы можно оставить в заголовке.

В main.cpp должна быть реализована программа, тестирующая указанный класс в подробном режиме,

выводя в stderr номера или названия испытаний и их результаты или ошибки. В ходе проверки

задания в первые два файла будут вносится незапланированные изменения, нарушающие работу

класса, и тестирующая программа должна их отлавливать (в том числе и на стадии компиляции,

т.е., она должна содержать явные или неявные обращения ко всем реализованным методам)

и грамотно диагностировать ошибки (в том числе и на стадии выполнения, например, если метод вернул не то, что должен), и ни в коем случае не "падать" сама, скажем, по защите памяти (segmentation fault).

Makefile должен содержать цели clean для уборки за собой, а также test,

которая компилирует main.cpp и прогоняет все тесты (по умолчанию подразумевается цель test).

Для класса, реализующего АТД, необходимо определить:

* конструктор по умолчанию

* конструктор копирования (глубокое копирование, никаких общих ресурсов!)

* операцию присваивания (все своё предварительно освободить + см. строку выше относительно копирования)

* деструктор (соответственно, никаких повторных освобождений!)

* базовый класс исключения, выбрасываемого всеми операциями класса, возможно

с потомками -- для более детальной классификации ошибок. Вложен в основной класс,

например string_list::error.
 стек строк (string stack)

строка понимается в стиле Си: char *, на конце \0.

Стек в обычном понимании (первый вошел -- последний вышел), в котором

хранятся строки с владением, т.е. при уничтожении вся выделенная под них

память освобождается. Для сравнения: хранение без владения означает, что

хранятся и удаляются лишь указатели, а память управляется кем-то еще, тогда

наш контейнер используется только для организации указателей.

Выбрать: 

1. Длина строки ограничена константой или объемом оперативной памяти.

2. Емкость стека ограничена константой или параметром конструктора или

объемом оперативной памяти.

Обязательные операции:

    stack::push( char* ) // положить копию строки

    char* stack::pop() // вернуть верхний элемент с удалением из стека

    char* stack::peek() // вернуть копию верхнего элемента без удаления

    int stack::length() // текущий размер

    int stack::maxsize() // максимальный размер (или -1, если "неограничен")

    stack + char* // синоним push

    stack - char*& // синоним pop, записывающий результат во второй операнд
