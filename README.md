# by sole
class stack of strings
Task2 - cmc - 4 sem

#### how it works: 

    :make pr
    :input | ./pr 

or

    :./pr

to test

    :make test
    :./test

#### commands: (/help) 

        push   - string to stack
        pop    - string from stack
        peek   - string from stack (no del)
        print  - print stack
        length - number of strings in stack
        size   - maxsize of stack
        stack+ - push str to stack
        stack- - pop to str, maxsize = 10
        
#### examples:

      push 1 2 3 4 5 push // now 1-5 in stack
      pop // 1-4 in stack
      peek // 1-4 in stack
      stack- str //now str = 4, 1-3 in stack
      stack+ s //stack: 1 2 3 s
      stack+ str //stack: 1 2 3 s 4
      pop pop pop pop pop 
      stack empty!
      
 -----------
      
## Task2: Stack of strings class

Необходимо на Си++ реализовать и протестировать новый класс, представляющий

абстрактный тип данных, т.е. такой, пользователи которого могут обращаться

только к публичными операциями, предусмотренными создателем класса, и не имеют

информации о внутреннем его устройстве.

Здесь и далее пользователем (клиентом) класса считается не "пользователь программы" или

"компьютерный пользователь" вообще, а программист, использующий Ваш класс

для решения своих задач, пишущий свою программу на его основе.

Иногда также под пользователями класса понимаются другие классы,

фрагменты программ, которые пользуются его услугами.

Ниже перечислены варианты понятий, которые нужно представить новым классом.

Можно определить несколько дополнительных классов, на том же уровне или вложенных,

однако основной проверке подвергается главный класс. В некоторых вариантах

есть подварианты -- одно- или двунаправленный список, чем ограничена длина строки и т.п.,

влияющие на сложность задания. Среди подвариантов нужно сделать свой выбор и отразить его в README.

Чем сложнее вариант/подварианты, тем больше баллов можно получить за выполненное задание.

  -----------
 == Требования ==
 
Программа формируется в виде следующего набора файлов:

        README
        Makefile
        string_stack.h
        string_stack.cpp
        main.cpp

В файле string_stack.h должно быть объявлено все, что необходимо включить в программу,

использующую класс string_stack, в string_stack.cpp -- описаны реализации нетривиальных методов класса

(если содержат более одного-двух операторов), краткие методы можно оставить в заголовке.

В main.cpp должна быть реализована программа, тестирующая указанный класс в подробном режиме,

выводя в stderr номера или названия испытаний и их результаты или ошибки.

Для класса, реализующего АТД, необходимо определить:

* конструктор по умолчанию

* конструктор копирования (глубокое копирование, никаких общих ресурсов!)

* операцию присваивания (все своё предварительно освободить + см. строку выше относительно копирования)

* деструктор (соответственно, никаких повторных освобождений!)

### стек строк (string stack)

строка понимается в стиле Си: char *, на конце \0.

Стек в обычном понимании (первый вошел -- последний вышел), в котором

хранятся строки с владением, т.е. при уничтожении вся выделенная под них

память освобождается. Для сравнения: хранение без владения означает, что

хранятся и удаляются лишь указатели, а память управляется кем-то еще, тогда

наш контейнер используется только для организации указателей.

Выбрать: 

1. Длина строки ограничена константой или объемом оперативной памяти.

2. Емкость стека ограничена константой или параметром конструктора или

объемом оперативной памяти.

Обязательные операции:

    stack::push( char* ) // положить копию строки
    char* stack::pop() // вернуть верхний элемент с удалением из стека
    char* stack::peek() // вернуть копию верхнего элемента без удаления
    int stack::length() // текущий размер
    int stack::maxsize() // максимальный размер (или -1, если "неограничен")
    stack + char* // синоним push
    stack - char*& // синоним pop, записывающий результат во второй операнд
